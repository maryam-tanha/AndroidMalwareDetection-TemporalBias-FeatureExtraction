package com.example.week2decodingapp;

import static android.os.Environment.getExternalStorageDirectory;

import android.Manifest;
import android.annotation.SuppressLint;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Environment;
import android.widget.Toast;

import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;

import com.google.common.collect.Sets;

import org.jf.dexlib2.DexFileFactory;
import org.jf.dexlib2.Opcodes;
import org.jf.dexlib2.ReferenceType;
import org.jf.dexlib2.iface.ClassDef;
import org.jf.dexlib2.iface.DexFile;
import org.jf.dexlib2.iface.Method;
import org.jf.dexlib2.iface.MethodImplementation;
import org.jf.dexlib2.iface.instruction.Instruction;
import org.jf.dexlib2.iface.instruction.ReferenceInstruction;
import org.jf.dexlib2.iface.reference.MethodReference;
import org.jf.dexlib2.util.ReferenceUtil;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import fr.xgouchet.axml.CompressedXmlParser;

public class MainActivity extends AppCompatActivity {

    private static final int REQUEST_CODE = 1;
    private static final String FILENAME = "InstalledAPKList.txt";
    private static final String FILEPATH = "SampleOutputs";

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        //Checks for permission to read an d write external storage.
        checkPermissions();

        //Creating a folder in external directory to save outputs.
        String createFolder = getExternalStorageDirectory()+"/"+FILEPATH;
        new File(createFolder);

        try {
            //Stores package names inside a .txt file for later use
            storeAPKList();

            String packageName = "com.Slack"; //installed package name
            String APKName = extractAPKName(packageName);
            String xmlFileName = APKName + "AndroidManifest.xml";

            extractManifestFromAPK(packageName, xmlFileName);
            StringBuilder content = readManifest(xmlFileName);
            createManifestFile(content, APKName);

            extractAPICalls(packageName, APKName);
        } catch (IOException | PackageManager.NameNotFoundException e) {
            e.printStackTrace();
        }
    }


    public static String extractAPKName(String input) {
        input = input.substring(4);
        StringBuilder sb = new StringBuilder();
        for (String s : input.split("\\.")) {
            sb.append(s.substring(0, 1).toUpperCase());
            sb.append(s.substring(1).toLowerCase());
        }
        return sb.toString();
    }


    public void checkPermissions() {
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ||
                ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_CODE);
        } else {
            // Permission has already been granted, you can read from external storage
            System.out.println("Permission Granted Already");
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == REQUEST_CODE) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED && grantResults[1] == PackageManager.PERMISSION_GRANTED) {
                // Permission granted
                System.out.println("Permissions Granted after asking.");
            } else {
                // Permission denied
                System.out.println("Permissions Denied after asking.");
            }
        }
    }

    /**
     * Checks for permissions to read and write external storage.
     * @return boolean
     */
    private boolean isExternalStorageAvailableForRW() {
        String extStorageState = Environment.getExternalStorageState();
        return extStorageState.equals(Environment.MEDIA_MOUNTED);
    }

    /**
     * Detects all the installed APKs on the android device(or emulator) using packageManager,
     * Creates a text file with all the package names and stores them into external storage.
     * @throws IOException when the file or folder is not found
     */
    private void storeAPKList() throws IOException {
        PackageManager packageManager = getPackageManager();
        @SuppressLint("QueryPermissionsNeeded") List<ApplicationInfo> packageNames = packageManager.getInstalledApplications(0);

        if (!isExternalStorageAvailableForRW()) {
            System.out.println("External Storage not available for RW");
        } else {
            File myExternalFile = new File(getExternalFilesDir(FILEPATH), FILENAME);

            FileOutputStream fos;
            fos = new FileOutputStream(myExternalFile);
            for (ApplicationInfo packageInfo : packageNames) {
                // Write the package name to the file
                fos.write((packageInfo.packageName + "\n").getBytes(StandardCharsets.UTF_8));
            }
            Toast.makeText(MainActivity.this, "Installed APK List stored to external storage.", Toast.LENGTH_SHORT).show();
            fos.close();
        }
    }


    //    private void readAPKFromStorage() throws IOException {
//        FileReader fr = null;
//        File myExternalFile = new File(getExternalFilesDir(FILEPATH), FILENAME);
//        StringBuilder stringBuilder = new StringBuilder();
//        BufferedReader br = null;
//        try {
//            fr = new FileReader(myExternalFile);
//            br = new BufferedReader(fr);
//            String line = br.readLine();
//            while (line != null) {
//                stringBuilder.append(line).append("\n");
//                line = br.readLine();
//            }
//
//        } catch (IOException e) {
//            assert fr != null;
//            fr.close();
//            br.close();
//            e.printStackTrace();
//        } finally {
//            String fileContents = "File Contents\n" + stringBuilder;
//            System.out.println(fileContents);
//        }
//    }

    /**
     * Extracts the APK file, then copies the content of AndroidManifest.xml to cache directory.
     */
    private void extractManifestFromAPK(String packageName, String xmlFileName) throws PackageManager.NameNotFoundException, FileNotFoundException {

        String apkFilePath = getPackageManager().getApplicationInfo(packageName, 0).sourceDir;

        ZipInputStream zipIs =  new ZipInputStream(new FileInputStream(apkFilePath));
        ZipEntry ze;
        try {
            while ((ze = zipIs.getNextEntry()) != null) {
                if (ze.getName().equals("AndroidManifest.xml")) {
                    FileOutputStream fout = new FileOutputStream(getCacheDir().getAbsolutePath() + "/" + xmlFileName);
                    byte[] buffer = new byte[1024];
                    int length;
                    while ((length = zipIs.read(buffer))>0) {
                        fout.write(buffer, 0, length);
                    }
                    zipIs.closeEntry();
                    fout.close();
                }
            }
            zipIs .close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Reads and converts the Binary XML(AXML) file into human readable XML file.
     * @throws IOException when file not found
     * @return String output
     */
    private StringBuilder readManifest(String manifestFileName) throws IOException {
        try (FileInputStream is = new FileInputStream(new File(getCacheDir(), manifestFileName))) {
            System.out.println("Print Manifest Content");
            Document doc = new CompressedXmlParser().parseDOM(is);
            //TODO: Write the content of XML file to a text file.
            StringBuilder content = new StringBuilder();
            dumpNode(doc.getChildNodes().item(0), "", content);
            return content;
        } catch (Exception e) {
            System.err.println("Failed AXML decode: " + e);
            e.printStackTrace();
        }
        return null;
    }

    private void createManifestFile(StringBuilder content, String apkName) throws IOException {
        String filename = apkName + "Manifest.txt";
        File myExternalFile = new File(getExternalFilesDir(FILEPATH), filename);
        FileOutputStream fos;
        fos = new FileOutputStream(myExternalFile);
        fos.write((String.valueOf(content)).getBytes(StandardCharsets.UTF_8));
        Toast.makeText(MainActivity.this, "Manifest File stored to external storage.", Toast.LENGTH_SHORT).show();
        fos.close();
    }

    /**
     * Code Help taken from https://github.com/xgouchet/AXML/blob/master/demo/src/DumpApkXml.java
     */
    private void dumpNode(Node node, String indent, StringBuilder content) {
        String line = (indent + node.getNodeName() + " " + attrsToString(node.getAttributes()) + " -> " + node.getNodeValue());
        content.append(line).append("\n");
        NodeList children = node.getChildNodes();
        for (int i = 0, n = children.getLength(); i < n; ++i)
            dumpNode(children.item(i), indent + "   ", content);
    }

    private static String attrsToString(NamedNodeMap attrs) {
        StringBuilder sb = new StringBuilder();
        sb.append('[');
        for (int i = 0, n = attrs.getLength(); i < n; ++i) {
            if (i != 0)
                sb.append(", ");
            Node attr = attrs.item(i);
            sb.append(attr.getNodeName()).append("=").append(attr.getNodeValue());
        }
        sb.append(']');
        return sb.toString();
    }

    /**
     * Extracts the API calls out dex file
     * @throws PackageManager.NameNotFoundException when package not found
     * @throws IOException when APK file path not found
     */
    private void extractAPICalls(String packageName, String apkName) throws PackageManager.NameNotFoundException, IOException {
        try {
            String apkFilePath = getPackageManager().getApplicationInfo(packageName, 0).sourceDir;
            extractAPICallsHelper(apkFilePath, apkName);
        } catch (PackageManager.NameNotFoundException | IOException e) {
            System.out.println("ERROR: There was a problem with extracting the API calls out of Classes.dex files.");
            e.printStackTrace();
        }
    }

    /**
     * Extracts the API calls out of Dex files using the DexFile Library
     * @param apkFilePath String
     * @throws IOException thrown when file not found
     */
    private void extractAPICallsHelper(String apkFilePath, String apkName) throws IOException {
        DexFile dexFile = DexFileFactory.loadDexFile(apkFilePath, Opcodes.forApi(15));
        Set<MethodReference> calledMethods = Sets.newHashSet();

        for (ClassDef classDef: dexFile.getClasses()) {
            for (Method method: classDef.getMethods()) {
                MethodImplementation implementation = method.getImplementation();
                if (implementation != null) {
                    for (Instruction instruction: implementation.getInstructions()) {
                        if (instruction.getOpcode().referenceType == ReferenceType.METHOD) {
                            calledMethods.add((MethodReference)((ReferenceInstruction)instruction).getReference());
                        }
                    }
                }
            }
        }

        String filename = apkName + "_api_calls.txt";
        File myExternalFile = new File(getExternalFilesDir(FILEPATH), filename);
        FileOutputStream fos;
        fos = new FileOutputStream(myExternalFile);
        for (MethodReference methodReference: calledMethods) {
            fos.write(Objects.requireNonNull(ReferenceUtil.getReferenceString(methodReference)).getBytes(StandardCharsets.UTF_8));
        }
        Toast.makeText(MainActivity.this, "API Calls File stored to external storage.", Toast.LENGTH_SHORT).show();
        fos.close();
    }
}


