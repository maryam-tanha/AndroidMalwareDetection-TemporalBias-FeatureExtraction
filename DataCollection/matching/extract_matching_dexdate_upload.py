import argparse
import os.path

import requests
from tqdm import tqdm
import csv
import sys

def get_meta_data(pkg_name, vers_code, api_key):
    url = f'https://androzoo.uni.lu/api/get_gp_metadata/{pkg_name}/{vers_code}'
    params = {'apikey': api_key}

    response = requests.get(url, params)
    response.raise_for_status()  # Raise HTTPError for bad status codes
    data = response.json()
    upload_date = data[0]['details']['appDetails']['uploadDate']
    return upload_date


def check_csv_exists(csv_name):
    if not os.path.exists(csv_name):
        with open(csv_name, 'w', newline='') as output_csv:
            csv_writer = csv.writer(output_csv)
            csv_writer.writerow(['sha256', 'pkg_name', 'ver_code', 'upload_date', 'dex_date','vt_detection', 'market'])


if __name__ == '__main__':

	parser = argparse.ArgumentParser(description='Script to verify APK upload dates before downloading. Use the extracted '
		                                         'output from latest.csv.gz with apks with the same dex_year as input'
		                                         'This script goes through the lines, checks they are from the '
		                                         'specified year, and adds it to an output CSV file. ')
	parser.add_argument('-t', '--type', type=str, required=True, help='Type of an app, b for benign , m for malware')
	parser.add_argument('-y', '--year', type=str, required=True, help='Year to check.')
	parser.add_argument('-csv', '--csv_name', type=str, required=True, help='Path to CSV output file. '
			                                                                'Creates it if it does not exist')
	parser.add_argument('-k', '--api_key', type=str, required=True, help='API key.')
	parser.add_argument('-i', '--input', type=str, required=True, help='Path to hashes to check.')
	args = parser.parse_args()

	apk_type = args.type
	year = args.year
	csv_file_name = args.csv_name
	api_key = args.api_key
	hashes_to_check = args.input
	
	if apk_type == 'b':
	
		no_response_file = open('results/'+year+'/benign_'+year+'_dex_no_response.txt','w')
		error_file= open('results/'+year+'/benign_'+year+'_dex_error_file.txt','w')
	elif apk_type == 'm':
		no_response_file = open('results/'+year+'/malware_'+year+'_dex_no_response.txt','w')
		error_file= open('results/'+year+'/malware_'+year+'_dex_error_file.txt','w')
	else:
		print('Incorrect input for apk type! Plesae choose ''b'' for benign and ''m'' for malware')
		sys.exit(1)
	
	check_csv_exists(csv_file_name)
	
	no_response_list = []
	with open(csv_file_name, 'a', newline='') as output_csv:
		csv_writer = csv.writer(output_csv)

		with open(hashes_to_check, 'r') as input_file:
			next(input_file)
			lines = input_file.readlines()

			
			error_list = []
			app_count = 0
			
			
			try:
				with tqdm(total=len(lines), ncols=0) as pbar:

					for line in lines:
						
						try:
							split_line = line.split()
							
							#hash_code = split_line[0].lstrip("0")
							hash_code = split_line[0]
							pkg_name = split_line[5][1:-1]
							ver_code = split_line[6]
							vt_detection = split_line[3]
							market = split_line[4]
							dex_date=split_line[1:3]
						except Exception as e:
							print(f'Error in reading the line {line}')
							print(e)
							
							error_list.append(line) 
							
							continue
						

						try:
							upload_date = get_meta_data(pkg_name, ver_code, api_key)
							
							if year in upload_date:
								row = [hash_code, pkg_name, ver_code, upload_date, dex_date,vt_detection, market]
								
								csv_writer.writerow(row)
								
								print(f'Success!')
								output_csv.flush()
								app_count += 1
								
								pbar.update(1)
						except Exception as e:
							print(f'No response for {hash_code}')
							print(e)
							no_response_list.append(line) 
							
							continue

			except KeyboardInterrupt:
				print('Caught Keyboard Interrupt, saving current lines.')
				
	
	
	
	for item in no_response_list:
		no_response_file.write(item+"\n")
	no_response_file.close()
	
	for item in error_list:
		error_file.write(item+"\n")
	error_file.close()
		    
