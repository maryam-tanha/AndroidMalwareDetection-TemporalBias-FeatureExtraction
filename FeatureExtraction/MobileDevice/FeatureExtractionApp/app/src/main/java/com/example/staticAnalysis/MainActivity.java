package com.example.staticAnalysis;

import static android.os.Environment.getExternalStorageDirectory;
import org.jf.dexlib2.DexFileFactory;
import org.jf.dexlib2.Opcodes;
import org.jf.dexlib2.dexbacked.DexBackedClassDef;
import org.jf.dexlib2.dexbacked.reference.DexBackedFieldReference;
import org.jf.dexlib2.dexbacked.reference.DexBackedMethodReference;
import org.jf.dexlib2.dexbacked.ZipDexContainer;
import org.jf.dexlib2.iface.MultiDexContainer;
import org.jf.dexlib2.dexbacked.DexBackedDexFile;
import android.Manifest;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.os.Bundle;
import android.os.Environment;
import android.util.SparseBooleanArray;
import android.widget.ArrayAdapter;
import android.widget.Button;
import android.widget.ListView;
import android.widget.TextView;
import android.widget.Toast;
import androidx.annotation.NonNull;
import androidx.appcompat.app.AppCompatActivity;
import androidx.core.app.ActivityCompat;
import androidx.core.content.ContextCompat;
import com.google.common.collect.ImmutableSet;
import org.w3c.dom.Document;
import org.w3c.dom.NamedNodeMap;
import org.w3c.dom.Node;
import org.w3c.dom.NodeList;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;
import fr.xgouchet.axml.CompressedXmlParser;


public class MainActivity extends AppCompatActivity {

    private static final int REQUEST_CODE = 1;
    private static final String FILENAME = "InstalledAPKList.txt";
    private static final String FILEPATH = "APKsList";
    private final String IP = "";
    private final int PORT = 8005;
    private TextView textView;
    private ListView listView;
    private Button extractButton;

    public static final Set<String> androidApiPackages = ImmutableSet.copyOf(Arrays.asList(
            "Landroid/",
            "Lcom/android/internal/util",
            "Ldalvik/",
            "Ljava/",
            "Ljavax/",
            "Lorg/apache/",
            "Lorg/json/",
            "Lorg/w3c/dom/",
            "Lorg/xml/sax",
            "Lorg/xmlpull/v1/",
            "Ljunit/"
    ));
    public static final Set<String> androidApiPrefixes = new HashSet<>(androidApiPackages);

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        textView = findViewById(R.id.textView);
        listView = findViewById(R.id.listView);
        extractButton = findViewById(R.id.extractButton);

        //Checks for permission to read and write external storage.
        checkPermissions();

        //Creating a folder in external directory to save outputs.
        String createFolder = getExternalStorageDirectory() + "/" + FILEPATH;
        new File(createFolder);

        try {
            // Detecting the APK files on the device.
            storeAPKList();
            HashSet<String> apps = readAPKListFromStorage();
            List<String> packageNames = new ArrayList<>(apps);

            loadListView(packageNames);

        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    /**
     * Loads detected APKs into the ListView and sets up onClick for extract Button.
     * @param packageNames List of the installed APKs
     */
    public void loadListView(List<String> packageNames) {
        List<String> selectedPackages = new ArrayList<>();

        String numAppInfo = packageNames.size() + " Apps Detected";
        textView.setText(numAppInfo);

        setupListView(packageNames, selectedPackages);
        extractButtonOnClick(selectedPackages);
    }

    /**
     * Sets up the ListView with package names for multiple selection.
     * This method initializes the ListView with the given package names and enables multiple selection.
     * It also handles item click events to add or remove selected packages and updates the extract button's state.
     *
     * @param packageNames     The list of all package names to be displayed in the ListView.
     * @param selectedPackages The list of initially selected package names.
     */
    private void setupListView(List<String> packageNames, List<String> selectedPackages) {
        ArrayAdapter<String> adapter = new ArrayAdapter<>(MainActivity.this,
                android.R.layout.simple_list_item_multiple_choice, new ArrayList<>(packageNames));
        listView.setAdapter(adapter);
        listView.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE);

        listView.setOnItemClickListener((parent, view1, position, id) -> {
            String selectedPackage = adapter.getItem(position);
            if (selectedPackages.contains(selectedPackage)) {
                selectedPackages.remove(selectedPackage);
            } else {
                selectedPackages.add(selectedPackage);
            }
            view1.setSelected(!view1.isSelected());
            extractButton.setEnabled(!selectedPackages.isEmpty());
        });
    }

    /**
     * Handles the click event of the extract button.
     * This method checks if the server is up and then initiates the process of extracting features
     * from selected APKs.
     *
     * @param selectedPackages The list of selected package names (APKs) to extract features from.
     */
    private void extractButtonOnClick(List<String> selectedPackages) {

        extractButton.setOnClickListener(view12 -> {
            ProgressDialogManager progressDialogManager = new ProgressDialogManager(this);
            CountDownLatch latch = new CountDownLatch(1);

            SocketTask socketTask = new SocketTask(MainActivity.this, IP,
                    PORT, progressDialogManager, latch);

            // Check if server is up before extracting features
            if (!socketTask.isServerUp()) {
                System.out.println(socketTask.isServerUp());
                Toast.makeText(this, "Unable to connect to server.", Toast.LENGTH_SHORT).show();
                return;
            }

            extractButton.setEnabled(false);
            Executor executor = Executors.newSingleThreadExecutor();
            executor.execute(() -> {
                try {
                    List<String> apkNames = new ArrayList<>();
                    for (String selectedPkgName : selectedPackages) {
                        String apkName = extractAPKName(selectedPkgName);
                        apkNames.add(apkName);
                    }

                    // Extract features
                    extractFeatures(selectedPackages, apkNames, progressDialogManager);

                    // Get feature directory paths
                    List<String> featureDirs = new ArrayList<>();
                    for (String apkName : apkNames) {
                        String apkDir = getFeaturesPath(apkName);
                        featureDirs.add(apkDir);
                    }

                    // Set feature directories and send over socket
                    socketTask.setAPKFeaturesDir(featureDirs);
                    socketTask.execute();
                    latch.await();

                } catch (IOException | PackageManager.NameNotFoundException | InterruptedException e) {
                    e.printStackTrace();
                } finally {
                    clearListView(selectedPackages);
                }
            });
        });
    }

    /**
     * Clears the list view of selected items.
     * @param selectedPackages List of selectedPackages
     */
    private void clearListView(List<String> selectedPackages) {
        runOnUiThread(() -> {
            ListView listView = findViewById(R.id.listView);
            SparseBooleanArray checkedItems = listView.getCheckedItemPositions();

            for (int i = 0; i < checkedItems.size(); i++) {
                int position = checkedItems.keyAt(i);
                if (checkedItems.get(position)) {
                    listView.setItemChecked(position, false);
                }
            }
        });

        selectedPackages.clear();
    }

    /**
     * Extracts features from selected APKs and displays progress using the provided ProgressDialogManager.
     * This method extracts AndroidManifest files, extracts features from manifest files,
     * and extracts API calls from the selected APKs, showing progress dialogs at each step.
     *
     * @param selectedPackages       The list of selected package names (APKs).
     * @param apkNames               The list of APK names from which to extract features.
     * @param progressDialogManager  The ProgressDialogManager for displaying progress dialogs.
     * @throws PackageManager.NameNotFoundException If a package name is not found.
     * @throws IOException                          If an I/O error occurs during extraction.
     */
    private void extractFeatures(List<String> selectedPackages, List<String> apkNames,
                                 ProgressDialogManager progressDialogManager) throws PackageManager.NameNotFoundException, IOException {
        progressDialogManager.showProgressDialog("Extracting AndroidManifest files");
        List<String> manifestFiles = extractManifestFromAPK(selectedPackages);

        progressDialogManager.showProgressDialog("Extracting Features from Manifest");
        extractDataFromManifest(manifestFiles, apkNames);

        progressDialogManager.showProgressDialog("Extracting API Calls");
        List<List<DexBackedDexFile>> DexFiles = extractAPICalls(selectedPackages, apkNames);

    }

    /**
     * Extracts and formats the APK name from a given input string.
     * This method removes the initial 4 characters from the input string and then
     * formats the remaining string by capitalizing the first letter of each word.
     *
     * @param input The input string containing the APK name.
     * @return The formatted APK name with capitalized first letters of each word.
     */
    public static String extractAPKName(String input) {
        input = input.substring(4);
        StringBuilder sb = new StringBuilder();
        for (String s : input.split("\\.")) {
            sb.append(s.substring(0, 1).toUpperCase());
            sb.append(s.substring(1).toLowerCase());
        }
        return sb.toString();
    }

    /**
     * Checks if the app has the necessary permissions for reading and writing external storage.
     * This method checks for the READ_EXTERNAL_STORAGE and WRITE_EXTERNAL_STORAGE permissions,
     * and requests them if they are not granted already.
     */
    public void checkPermissions() {
        if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED ||
                ContextCompat.checkSelfPermission(this, Manifest.permission.WRITE_EXTERNAL_STORAGE) != PackageManager.PERMISSION_GRANTED) {
            ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_EXTERNAL_STORAGE, Manifest.permission.WRITE_EXTERNAL_STORAGE}, REQUEST_CODE);
        } else {
            // Permission has already been granted, you can read from external storage
            System.out.println("Permission Granted Already");
        }
    }

    @Override
    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
        if (requestCode == REQUEST_CODE) {
            if (grantResults.length > 0 && grantResults[0] == PackageManager.PERMISSION_GRANTED && grantResults[1] == PackageManager.PERMISSION_GRANTED) {
                // Permission granted
                System.out.println("Permissions Granted after asking.");
            } else {
                // Permission denied
                System.out.println("Permissions Denied after asking.");
            }
        }
    }

    /**
     * Checks for permissions to read and write external storage.
     *
     * @return boolean
     */
    private boolean isExternalStorageAvailableForRW() {
        String extStorageState = Environment.getExternalStorageState();
        return extStorageState.equals(Environment.MEDIA_MOUNTED);
    }

    /**
     * Detects all the installed APKs on the android device(or emulator) using packageManager,
     * Creates a text file with all the package names and stores them into external storage.
     *
     * @throws IOException when the file or folder is not found
     */
    private void storeAPKList() throws IOException {
        PackageManager packageManager = getPackageManager();
        List<ApplicationInfo> packageNames = packageManager.getInstalledApplications(0);

        if (!isExternalStorageAvailableForRW()) {
            System.out.println("External Storage not available for RW");
        } else {
            File myExternalFile = new File(getExternalFilesDir(FILEPATH), FILENAME);

            FileOutputStream fos;
            fos = new FileOutputStream(myExternalFile);
            for (ApplicationInfo packageInfo : packageNames) {
                // Write the package name to the file
                if ((packageInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) {
                    // 1. Applications downloaded from Google Play Store
                    fos.write((packageInfo.packageName + "\n").getBytes(StandardCharsets.UTF_8));
                }
            }
            Toast.makeText(MainActivity.this, "Installed APK List stored to external storage.", Toast.LENGTH_SHORT).show();
            fos.close();
        }
    }

    /**
     * Reads the list of APK names from storage and returns them as a HashSet.
     *
     * @return A HashSet containing the list of APK names read from storage.
     * @throws IOException If an I/O error occurs while reading the APK list from storage.
     */
    private HashSet<String> readAPKListFromStorage() throws IOException {
        FileReader fr = null;
        File myExternalFile = new File(getExternalFilesDir(FILEPATH), FILENAME);
        HashSet<String> appsList = new HashSet<>();
        BufferedReader br = null;
        try {
            fr = new FileReader(myExternalFile);
            br = new BufferedReader(fr);
            String line = br.readLine();
            while (line != null) {
                appsList.add(line);
                line = br.readLine();
            }
        } catch (IOException e) {
            assert fr != null;
            fr.close();
            br.close();
            e.printStackTrace();
        } finally {
            assert fr != null;
            fr.close();
            assert br != null;
            br.close();
        }
        return appsList;
    }

    /**
     * Extracts manifest files from APKs corresponding to the given package names.
     *
     * @param packageNames The list of package names of the APKs.
     * @return An ArrayList containing the filenames of extracted manifest files.
     * @throws PackageManager.NameNotFoundException If a package name is not found.
     * @throws IOException                          If an I/O error occurs during extraction.
     */
    private ArrayList<String> extractManifestFromAPK(List<String> packageNames) throws PackageManager.NameNotFoundException, IOException {
        ArrayList<String> manifestFileNames = new ArrayList<>();
//        ArrayList<String> apkNames = new ArrayList<>();
        for (String packageName : packageNames) {
            String apkName = extractAPKName(packageName);
//            apkNames.add(apkName);
            String xmlFileName = apkName + "AndroidManifest.xml";
            String apkFilePath = getPackageManager().getApplicationInfo(packageName, 0).sourceDir;
            ZipInputStream zipIs = new ZipInputStream(new FileInputStream(apkFilePath));
            ZipEntry ze;

            while ((ze = zipIs.getNextEntry()) != null) {
                if (ze.getName().equals("AndroidManifest.xml")) {
                    FileOutputStream fout = new FileOutputStream(getCacheDir().getAbsolutePath() + "/" + xmlFileName);
                    byte[] buffer = new byte[1024];
                    int length;
                    while ((length = zipIs.read(buffer)) > 0) {
                        fout.write(buffer, 0, length);
                    }
                    zipIs.closeEntry();
                    fout.close();
                }
            }
            zipIs.close();

            StringBuilder content = readManifest(xmlFileName);
            String manifestFileName = createManifestFile(content, apkName);
            manifestFileNames.add(manifestFileName);
        }
        return manifestFileNames;
    }

    /**
     * Reads and converts the Binary XML(AXML) file into human readable XML file.
     *
     * @return String output
     */
    private StringBuilder readManifest(String manifestFileName) {
        try (FileInputStream is = new FileInputStream(new File(getCacheDir(), manifestFileName))) {
            Document doc = new CompressedXmlParser().parseDOM(is);
            StringBuilder content = new StringBuilder();
            dumpNode(doc.getChildNodes().item(0), "", content);
            return content;
        } catch (Exception e) {
            System.err.println("Failed AXML decode: " + e);
            e.printStackTrace();
        }
        return null;
    }

    /**
     * Creates a manifest file with the specified content and APK name in external storage.
     *
     * @param content  The content to be written to the manifest file.
     * @param apkName  The name of the APK associated with the manifest file.
     * @return The filename of the created manifest file.
     * @throws IOException If an I/O error occurs while creating the manifest file.
     */
    private String createManifestFile(StringBuilder content, String apkName) throws IOException {
        String filename = apkName + "Manifest.txt";
        File myExternalFile = new File(getExternalFilesDir(apkName), filename);
        FileOutputStream fos;
        fos = new FileOutputStream(myExternalFile);
        fos.write((String.valueOf(content)).getBytes(StandardCharsets.UTF_8));
//        Toast.makeText(MainActivity.this, "Manifest File stored to external storage.", Toast.LENGTH_SHORT).show();
        fos.close();
        return filename;
    }

    /**
     * Extracts and returns the substring between the first occurrence of "[" and the following "]" in the input string.
     *
     * @param input The input string from which to extract the substring.
     * @return The substring between "[" and "]" in the input string, or null if the brackets are not found.
     */
    public static String getStringBetweenBrackets(String input) {
        int startIndex = input.indexOf("[") + 1;
        int endIndex = input.indexOf("]");
        if (startIndex - 1 == -1 || endIndex == -1) {
            return null;
        }
        return input.substring(startIndex, endIndex);
    }

    /**
     * Extracts data from manifest files associated with APKs and writes the extracted data to output files.
     *
     * @param manifestFileNames The list of manifest file names to be processed.
     * @param apkNames          The list of APK names corresponding to the manifest files.
     * @throws IOException If an I/O error occurs while reading or writing files.
     */
    private void extractDataFromManifest(List<String> manifestFileNames, List<String> apkNames) throws IOException {

        for (int i = 0; i < manifestFileNames.size(); i++) {
            String manifestFileName = manifestFileNames.get(i);
            String apkName = apkNames.get(i);

            File manifestFile = new File(getExternalFilesDir(apkName), manifestFileName);
            BufferedReader reader = new BufferedReader(new FileReader(manifestFile));

            List<String> hardwareSoftwareList = new ArrayList<>();
            List<String> permissionList = new ArrayList<>();

            // creating HashSet for storing intents
            HashSet<String> intentSet = new HashSet<>();

            String line;
            while ((line = reader.readLine()) != null) {
                if (line.contains("uses-feature")) {
                    String output = getStringBetweenBrackets(line);
                    hardwareSoftwareList.add(output);
                } else if (line.contains("action [")) {
                    String output = getStringBetweenBrackets(line);
                    intentSet.add(output);
                } else if (line.contains("uses-permission")) {
                    String output = getStringBetweenBrackets(line);
                    permissionList.add(output);
                }
            }
            reader.close();

            String hwFileName = apkName + "-hw-sw.txt";
            writeOutputFile(hardwareSoftwareList, hwFileName, apkName);

            String intentFileName = apkName + "-intent-actions.txt";
            writeOutputFile(intentSet, intentFileName, apkName);

            String permissionFileName = apkName + "-permissions.txt";
            writeOutputFile(permissionList, permissionFileName, apkName);
        }
    }

    /**
     * Writes a text file to external storage from a collection data structure.
     *
     * @param content  Collection; iterable to iterate over and write content ot output file
     * @param fileName String; output file name
     */
    private void writeOutputFile(Collection<String> content, String fileName, String apkName) {
        try {
            File myFile = new File(getExternalFilesDir(apkName), fileName);
            FileOutputStream fos;
            fos = new FileOutputStream(myFile);
            for (String line : content) {
                fos.write((line + "\n").getBytes(StandardCharsets.UTF_8));
            }
            fos.close();
            System.out.println("SUCCESS: Output File: " + fileName + " created and filled.");
        } catch (IOException e) {
            System.out.println("ERROR: An error occurred while writing content to external storage.");
            e.printStackTrace();
        }
    }

    /**
     * Code Help taken from <a href="https://github.com/xgouchet/AXML/blob/master/demo/src/DumpApkXml.java">...</a>
     */
    private void dumpNode(Node node, String indent, StringBuilder content) {
        String line = (indent + node.getNodeName() + " " + attrsToString(node.getAttributes()));
        content.append(line).append("\n");
        NodeList children = node.getChildNodes();
        for (int i = 0, n = children.getLength(); i < n; ++i)
            dumpNode(children.item(i), indent + "   ", content);
    }

    /**
     * Converts attributes from a NamedNodeMap to a formatted string enclosed in square brackets.
     *
     * @param attrs The NamedNodeMap containing attributes to be converted.
     * @return A string representation of attributes enclosed in square brackets.
     */
    private static String attrsToString(NamedNodeMap attrs) {
        StringBuilder sb = new StringBuilder();
        sb.append('[');
        if (attrs.getLength() > 0) {
            Node attr = attrs.item(0);
            sb.append(attr.getNodeValue());
        }
        sb.append(']');
        return sb.toString();
    }

    /**
     * Extracts API calls from Dex files associated with the given package names and APK names.
     *
     * @param packageNames The list of package names corresponding to the APKs.
     * @param apkNames     The list of APK names.
     * @return A nested list containing DexBackedDexFile objects representing extracted API calls.
     * @throws IOException If an I/O error occurs during API call extraction.
     */
    private List<List<DexBackedDexFile>> extractAPICalls(List<String> packageNames, List<String> apkNames) throws IOException {
        List<DexBackedDexFile> dexFilesList;
        List<List<DexBackedDexFile>> nestedList = new ArrayList<>();
        for (int i = 0; i < packageNames.size(); i++) {
            String packageName = packageNames.get(i);
            String apkName = apkNames.get(i);
            try {
                String apkFilePath = getPackageManager().getApplicationInfo(packageName, 0).sourceDir;
                dexFilesList = extractAPICallHelper(apkFilePath, apkName);
                nestedList.add(dexFilesList);
            } catch (PackageManager.NameNotFoundException e) {
                System.out.println("ERROR: " + "APK - " + apkName + " : occurred while extracting API calls out of Classes.dex files.");
                e.printStackTrace();
            }
        }
        return nestedList;
    }

    /**
     * Helper method to extract API calls from Dex files associated with the given APK file path and APK name.
     *
     * @param apkFilePath The file path of the APK containing the Dex files.
     * @param apkName     The name of the APK.
     * @return A list of DexBackedDexFile objects representing extracted Dex files containing API calls.
     * @throws IOException If an I/O error occurs during the extraction process.
     */
    public List<DexBackedDexFile> extractAPICallHelper(String apkFilePath, String apkName) throws IOException {
        List<DexBackedDexFile> dexFiles = new ArrayList<>();
        List<String> dexFileNames = extractAllDexFileNames(apkFilePath);

        HashSet<String> api_calls = new HashSet<>();

        if (dexFileNames != null) {
            for (String dexFileName : dexFileNames) {
                MultiDexContainer.DexEntry<? extends DexBackedDexFile> dexEntry = loadDexFile(dexFileName, apkFilePath);
                DexBackedDexFile dexFile = dexEntry.getDexFile();
                dexFiles.add(dexFile);
            }
        } else {
            System.out.println("ERROR: No files with .dex suffix found in the APK provided.");
        }

        //Implement a hashset that records all the class names in the dexFile
        Set<String> definedClasses = new HashSet<>();

        //        int counter = 0; //Used for debugging purposes.
        for (DexBackedDexFile dexFile : dexFiles) {

            Set<? extends DexBackedClassDef> classes = dexFile.getClasses();

            for (DexBackedClassDef item : classes) {
                definedClasses.add(item.toString());
            }

            DexBackedDexFile.IndexedSection<DexBackedMethodReference> methods = dexFile.getMethodSection();
            DexBackedDexFile.IndexedSection<DexBackedFieldReference> fields = dexFile.getFieldSection();

            for (DexBackedMethodReference method : methods) {
                String className = method.getDefiningClass();
                if (!definedClasses.contains(className)) {
                    for (String apiCandidatePrefix : androidApiPrefixes) {
                        if (className.startsWith(apiCandidatePrefix)) {
//                            counter++; //DEBUG
                            api_calls.add(className + "->" + method.getName());
                            break;
                        }
                    }
                }
            }
        }

        // Debugging Lines
        // api_calls.forEach(System.out::println);
        // System.out.println("Counter: " + counter);
        // System.out.println("Set Length: " + api_calls.size());

        String apiCallFilename = apkName + "-api-calls.txt";
        writeOutputFile(api_calls, apiCallFilename, apkName);

        return dexFiles;
    }

    /**
     * Extracting names of dex files from APK Archive.
     *
     * @param apkFilePath String
     * @return ArrayList
     */
    public static ArrayList<String> extractAllDexFileNames(String apkFilePath) {

        try {
            // Extract the names of dex file from APK
            ZipDexContainer multiDexContainer = (ZipDexContainer) DexFileFactory.loadDexContainer(new File(apkFilePath), Opcodes.forApi(16));
            return new ArrayList<>(multiDexContainer.getDexEntryNames());

        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }
    }

    /**
     * Loading the dex file by providing the name of dex file.
     *
     * @param dexFileName String; Name of dex file, for example: Classes.dex, Classes2.dex, etc.
     * @param apkFilePath String; APK FIle Path
     * @return MultiDexContainer File
     * @throws IOException when filename not found
     */
    private static MultiDexContainer.DexEntry<? extends DexBackedDexFile> loadDexFile(String dexFileName, String apkFilePath) throws IOException {
        return DexFileFactory.loadDexEntry(new File(apkFilePath), dexFileName, true, Opcodes.forApi(16));
    }

    /**
     * Retrieves the path of the directory containing features for a given APK name.
     *
     * @param apkName The name of the APK for which the features directory path is required.
     * @return The absolute path of the directory containing features for the specified APK,
     *         or null if the directory is not found.
     */
    private String getFeaturesPath(String apkName) {
        String apkDir = null;
        File externalDir = getExternalFilesDir(null);

        if (externalDir != null && externalDir.isDirectory()) {
            File[] files = externalDir.listFiles();

            assert files != null;
            for (File file : files) {
                if (!file.getName().equals("APKsList") && file.getName().equals(apkName)) {
                    apkDir = file.getAbsolutePath();
                }
            }
        }

        return apkDir;
    }
}