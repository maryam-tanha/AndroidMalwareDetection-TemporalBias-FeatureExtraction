package com.example.staticAnalysis;

import android.app.Activity;
import android.content.Context;
import android.widget.Toast;
import java.io.BufferedReader;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.Executor;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * Represents a task for handling socket transfer of extracted feature directories.
 */
public class SocketTask {
    private final Context context;
    private final String serverAddress;
    private final int serverPort;
    private List<String> apkFeaturesDir;
    private final ProgressDialogManager progressDialogManager;
    private final CountDownLatch latch;

    /**
     * Constructs a SocketTask object with the specified parameters.
     *
     * @param context               The context of the activity or application.
     * @param serverAddress         The IP address of the server to connect to.
     * @param serverPort            The port number of the server.
     * @param progressDialogManager The ProgressDialogManager for managing progress dialogs.
     * @param latch                 The CountDownLatch for synchronizing threads.
     */
    public SocketTask(Context context, String serverAddress, int serverPort,
                      ProgressDialogManager progressDialogManager, CountDownLatch latch) {
        this.context = context;
        this.serverAddress = serverAddress;
        this.serverPort = serverPort;
        this.progressDialogManager = progressDialogManager;
        this.latch = latch;
    }

    /**
     * Executes the transfer of APK feature directories to the server asynchronously.
     * This method initiates the transfer process for each feature directory,
     * handles I/O operations with the server, and manages progress dialogs.
     */
    public void execute() {
        AtomicBoolean exceptionOccurred = new AtomicBoolean(false);
        ExecutorService executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> {
            try (
                    Socket socket = new Socket(serverAddress, serverPort);
                    BufferedReader reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
                    OutputStream outputStream = socket.getOutputStream()
            ) {
                for (String dir : apkFeaturesDir) {
                    String[] path = dir.split("/");
                    String apkName = path[path.length - 1];

                    progressDialogManager.showProgressDialog("Sending " + apkName);

                    // Initiate transfer and wait for START
                    outputStream.write("TRANSFER".getBytes());
                    String start = reader.readLine();
                    System.out.println("From Server: " + start);

                    // Send APK feature directory name first and wait for BEGIN_TRANSFER
                    outputStream.write(apkName.getBytes());
                    String beginTransfer = reader.readLine();
                    System.out.println("From Server: " + beginTransfer);

                    // Zip the feature directory
                    File apkFolderZip = new File(dir);
                    zipDirectory(apkFolderZip);

                    // Send zipped directory
                    sendZip(dir + ".zip", reader, outputStream);

                    // Wait for TRANSFER_COMPLETE
                    String transferComplete = reader.readLine();
                    System.out.println("From Server: " + transferComplete);
                }
            } catch (IOException e) {
                e.printStackTrace();
                exceptionOccurred.set(true);
                ((Activity) context).runOnUiThread(() -> Toast.makeText(context, "Error during connection.",
                        Toast.LENGTH_SHORT).show());

            } finally {
                latch.countDown();
                progressDialogManager.dismissProgressDialog();
                if (!exceptionOccurred.get()) {
                    ((Activity) context).runOnUiThread(() -> Toast.makeText(context, "Server received extracted features.",
                            Toast.LENGTH_SHORT).show());
                }
            }
        });
        executor.shutdown();
    }

    /**
     * Sets the apkFeaturesDir.
     * @param apkFeaturesDir List of apk feature directories
     */
    public void setAPKFeaturesDir(List<String> apkFeaturesDir) {
        this.apkFeaturesDir = apkFeaturesDir;
    }

    /**
     * Compresses a directory and its contents into a Zip file.
     *
     * @param directory The directory to be compressed.
     * @throws IOException If an I/O error occurs while reading or writing files.
     */
    private void zipDirectory(File directory) throws IOException {
        FileOutputStream fos = new FileOutputStream(directory.getAbsolutePath() + ".zip");
        ZipOutputStream zos = new ZipOutputStream(fos);
        zip(directory, zos);
        zos.close();
        fos.close();
    }

    /**
     * Recursively compresses the contents of a directory into a ZipOutputStream.
     *
     * @param directory The apk feature directory.
     * @param zos The ZipOutputStream to which the compressed data is written.
     * @throws IOException If an I/O error occurs while reading or writing the files.
     */
    private void zip(File directory, ZipOutputStream zos) throws IOException {
        File[] files = directory.listFiles();
        byte[] buffer = new byte[4096];
        int bytesRead;
        assert files != null;
        for (File file : files) {
            if (file.isDirectory()) {
                zip(file, zos);
            } else {
                FileInputStream fis = new FileInputStream(file);
                String entryName = file.getAbsolutePath().substring(directory.getAbsolutePath().length() + 1);
                ZipEntry entry = new ZipEntry(entryName);
                zos.putNextEntry(entry);
                while ((bytesRead = fis.read(buffer)) != -1) {
                    zos.write(buffer, 0, bytesRead);
                }
                fis.close();
            }
        }
    }

    /**
     * Sends zipped apk feature directory over an OutputStream after obtaining its size and
     * receiving a response from the server.
     *
     * @param zipPath The path of the zip to be sent.
     * @param reader   The BufferedReader used to read responses from the server.
     * @param outputStream The OutputStream to which the file data is written.
     * @throws IOException If an I/O error occurs while reading or writing the file or communicating with the server.
     */
    private void sendZip(String zipPath, BufferedReader reader, OutputStream outputStream) throws IOException {
        File file = new File(zipPath);
        byte[] buffer = new byte[4096];
        int bytesRead;
        FileInputStream fis = new FileInputStream(file);

        long zipSize = file.length();
//        System.out.println("File size: " + zipSize);
        DataOutputStream dos = new DataOutputStream(outputStream);
        dos.writeLong(zipSize);

        // Wait for SEND_ZIP to send zip
        String res = reader.readLine();
        System.out.println("From server: " + res);

        while ((bytesRead = fis.read(buffer)) != -1) {
            outputStream.write(buffer, 0, bytesRead);
        }
        fis.close();
        outputStream.flush();
        file.delete();
    }

    /**
     * Checks if the server is up before sending feature directories.
     * @return True if up, else False
     */
    public boolean isServerUp() {
        AtomicBoolean isServerUp = new AtomicBoolean(false);
        CountDownLatch latch = new CountDownLatch(1);

        Executor executor = Executors.newSingleThreadExecutor();
        executor.execute(() -> {
            try (Socket socket = new Socket()) {
                socket.connect(new InetSocketAddress(this.serverAddress, this.serverPort));
                isServerUp.set(true);
            } catch (IOException e) {
                isServerUp.set(false);
            } finally {
                latch.countDown();
            }
        });

        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        return isServerUp.get();
    }
}