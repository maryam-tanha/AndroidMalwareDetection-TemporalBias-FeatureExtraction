import logging
import os
import pathlib
import time

from androguard.core.bytecodes.apk import APK
from androguard.misc import AnalyzeAPK
import asyncio


class App(object):
    """
    this class describes an app
    """

    def __init__(self, app_path):
        """
        create a App instance
        :param app_path: local file path of app
        :return:
        """
        assert app_path is not None
        self.logger = logging.getLogger(self.__class__.__name__)

        self.app_path = app_path

        self.apk, self.dex_files, self.dx = AnalyzeAPK(self.app_path)

        self.permissions = self.apk.get_permissions()
        # self.queries = self.apk.get_all_attribute_value("queries", "name")

    def extract_permissions(self):
        return set(list(self.permissions))

    def extract_intent_actions(self):
        # Intent filter are attached to activities, services or receivers.
        activities = self.apk.get_activities()
        receivers = self.apk.get_receivers()
        services = self.apk.get_services()
        filter_list = []
        actions_list = []

        for i in activities:
            filters = self.apk.get_intent_filters("activity", i)
            if filters is not None and len(filters) > 0 and 'action' in filters:
                actions_list.extend(filters['action'])

        for i in receivers:
            filters = self.apk.get_intent_filters("receiver", i)
            if filters is not None and len(filters) > 0 and 'action' in filters:
                actions_list.extend(filters['action'])

        for i in services:
            filters = self.apk.get_intent_filters("service", i)
            if filters is not None and len(filters) > 0 and 'action' in filters:
                actions_list.extend(filters['action'])

        return list(set(actions_list))

    def extract_hw_sw_features(self):
        return list(set(self.apk.get_features()))

    def extract_api_calls(self):
        # _, _, dx = AnalyzeAPK(self.app_path)
        # Detailed way of completing the task on above line
        # dx = Analysis()
        # for dex_bytes in self.apk.get_all_dex():
        #     df = DalvikVMFormat(dex_bytes, using_api=self.apk.get_target_sdk_version())
        #     dx.add(df)
        #
        # dx.create_xref()

        api_calls = set()

        for cl in self.dx.get_external_classes():
            for meth in cl.get_methods():
                if meth.is_android_api():
                    tmp_list = str(meth.get_method()).split("(")
                    api_calls.add(tmp_list[0])

        return list(api_calls)

    def extract_metrics(self):
        # We are getting the first dex file out of the list of dexFiles to get results that are similar to the
        # results from the original Research Article.
        dex_files = self.dex_files

        count_classes = 0
        count_methods = 0
        count_fields = 0
        count_instructions = 0
        count_if_instructions = 0

        # Metrics to calculate
        methods_per_class = 0
        instructions_per_method = 0
        cyclomatic_complexity = 0
        cyclomatic_complexity_v2 = 0
        weighted_methods_per_class = 0

        all_classes = set()
        all_fields = set()
        all_methods = set()
        all_instructions = set()
        all_if_instructions = set()

        for dex_file in dex_files:
            # count_fields += len(list(dex_file.get_fields()))
            all_fields.update(list(dex_file.get_fields()))
            # This for loop executes very fast, so no time complications here
            for dex_class in dex_file.get_classes():
                # count_classes += 1
                all_classes.add(dex_class.get_name())
                for method in dex_class.get_methods():
                    # count_methods += 1
                    all_methods.add(method.get_name())
                    for instruction in method.get_instructions():
                        # count_instructions += 1
                        all_instructions.add(instruction.get_name())
                        if instruction.get_name().startswith("if-"):
                            # count_if_instructions += 1
                            all_if_instructions.add(instruction.get_name())

        # total_classes = count_classes
        # total_fields = count_fields
        # total_methods = count_methods
        # total_instructions = count_instructions
        # total_if_instructions = count_if_instructions

        my_list = list(all_instructions)
        file_path = "output.txt"
        with open(file_path, "w") as file:
            for item in my_list:
                file.write(str(item) + "\n")

        total_classes = len(all_classes)
        total_fields = len(all_fields)
        total_methods = len(all_methods)
        total_instructions = len(all_instructions)
        total_if_instructions = len(all_if_instructions)

        # Calculate metrics
        try:
            methods_per_class = total_methods / total_classes
            instructions_per_method = total_instructions / total_methods
            cyclomatic_complexity = (total_if_instructions + 1) / total_classes
            cyclomatic_complexity_v2 = (total_if_instructions + 1)
            weighted_methods_per_class = methods_per_class * total_if_instructions
        except Exception as e:
            print(f"Error calculating metrics: {str(e)}")

        metrics_list = ["Total Classes: " + str(total_classes),
                        "Total Methods: " + str(total_methods),
                        "Total Fields: " + str(total_fields),
                        "Total Instructions: " + str(total_instructions),
                        "Instructions Per Method: " + str(instructions_per_method),
                        "Methods Per Class: " + str(methods_per_class),
                        "Cyclomatic Complexity v1: " + str(cyclomatic_complexity),
                        "Cyclomatic Complexity v2: " + str(cyclomatic_complexity_v2),
                        "WMC: " + str(weighted_methods_per_class)]
        return metrics_list

    def get_queries(self):
        """
        Return the android:name attribute of all queries
        :rtype: a list of str
        """
        return list(self.queries)

    def get_intents_from_queries(self, itemtype='queries'):

        attributes = {"action": ["name"], "category": ["name"],
                      "data": ['scheme', 'host', 'port', 'path', 'pathPattern', 'pathPrefix', 'mimeType']}

        d = {}
        for element in attributes.keys():
            d[element] = []

        for i in self.apk.xml:
            # TODO: this can probably be solved using a single xpath
            for item in self.apk.xml[i].findall(".//" + itemtype):

                for sitem in item.findall(".//intent"):
                    # print(sitem)
                    for element in d.keys():
                        for ssitem in sitem.findall(element):
                            if element == 'action':

                                for attribute in attributes[element]:

                                    value = ssitem.get(self.apk._ns(attribute))
                                    if value.startswith('@'):
                                        value = self.get_res_value(value)

                                    if value not in d[element]:
                                        d[element].append(value)

        for element in list(d.keys()):
            if not d[element] and element != "action":
                del d[element]

        return d['action']


def list_files(path):
    files_list = []
    for apk_file in os.listdir(path):
        file_path = os.path.join(path, apk_file)
        if os.path.isfile(file_path):
            temp_path = pathlib.Path(file_path)
            if temp_path.suffix == '.apk':
                files_list.append(file_path)
    return files_list


def create_features_file(feature_path, feature_name, a_name, feature_data):
    try:

        new_path = os.path.join(feature_path, a_name + feature_name + ".txt")

        with open(new_path, 'w') as file_obj:
            for data in feature_data:
                file_obj.write(data + '\n')

    except Exception as e:
        print(f"{e.__class__} occurred!\n {str(e)}")


async def process_apk(apk_path, error_apks):
    try:
        chosen_app = App(apk_path)
        apk_name = os.path.basename(apk_path)
        print(
            "--------------------------------------------------------------------------------------------------------------")
        print(f"Android app to be analyzed is {apk_name}")
        print(
            "--------------------------------------------------------------------------------------------------------------")

        app_name = apk_name.split(".")[0]

        try:
            features_path = os.path.join("E:\\AB501-1000ExtractedFeatures", app_name)
            if not os.path.exists(features_path):
                os.makedirs(features_path)  # Create parent directories if necessary
        except OSError as e:
            print(f"Error creating directory: {str(e)}")

        print("\nExtracting permissions...")
        perm_list = chosen_app.extract_permissions()
        create_features_file(features_path, "-permissions", app_name, perm_list)

        print("\nExtracting hardware and software features...")
        hw_sw_list = chosen_app.extract_hw_sw_features()
        create_features_file(features_path, "-hw-sw", app_name, hw_sw_list)

        print("\nExtracting all intent actions ...:")
        all_actions_list = list(set(chosen_app.extract_intent_actions() + chosen_app.get_intents_from_queries()))
        create_features_file(features_path, "-intent-actions", app_name, all_actions_list)

        print("\nExtracting API calls ...")
        all_api_list = chosen_app.extract_api_calls()
        create_features_file(features_path, "-api-calls", app_name, all_api_list)

        print(
            "--------------------------------------------------------------------------------------------------------------")
        print(f"End of analyzing {apk_name}")
    except Exception as e:
        print(f"Error Occurred: {e}")
        error_apks.append(apk_path)


async def main():
    error_apks = []
    apk_files_list = []
    dir_path = ["E:\\AndrozooBenign501-1000"]
    # dir_path = ["E:\\AndrozooBenign501-1000", "E:\\AndrozooBenign1001-1800",
    #             "E:\\AndrozooBenign1801-3000", "E:\\AndrozooBenign3001-5000", "E:\\AndrozooBenign5001-9000"]
    for path in dir_path:
        apk_files_list.extend(list_files(path))

    print(f"total apks to process: {len(apk_files_list)}")
    tasks = [process_apk(apk_path, error_apks) for apk_path in apk_files_list]

    # Run the tasks concurrently using asyncio
    await asyncio.gather(*tasks)


if __name__ == "__main__":
    asyncio.run(main())
