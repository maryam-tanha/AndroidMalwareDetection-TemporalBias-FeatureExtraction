import logging
import os
import pathlib
import time

from androguard.core.bytecodes.apk import APK
from androguard.misc import AnalyzeAPK


class App(object):
    """
    this class describes an app
    """

    def __init__(self, app_path):
        """
        create a App instance
        :param app_path: local file path of app
        :return:
        """
        assert app_path is not None
        self.logger = logging.getLogger(self.__class__.__name__)

        self.app_path = app_path

        self.apk, self.dex_files, self.dx = AnalyzeAPK(self.app_path)

        self.permissions = self.apk.get_permissions()
        # self.queries = self.apk.get_all_attribute_value("queries", "name")

    def extract_permissions(self):
        return set(list(self.permissions))

    def extract_intent_actions(self):
        # Intent filter are attached to activities, services or receivers.
        activities = self.apk.get_activities()

        receivers = self.apk.get_receivers()
        services = self.apk.get_services()
        filter_list = []
        actions_list = []
        for i in activities:
            filters = self.apk.get_intent_filters("activity", i)
            if len(filters) > 0:  # there is at least one intent-filter for activity i
                [actions_list.append(action) for action in filters['action'] if 'action' in filters]

        for i in receivers:
            filters = self.apk.get_intent_filters("receiver", i)
            if len(filters) > 0:  # there is at least one intent-filter for activity i
                [actions_list.append(action) for action in filters['action'] if 'action' in filters]

        for i in services:
            filters = self.apk.get_intent_filters("service", i)

            if len(filters) > 0:  # there is at least one intent-filter for activity i
                [actions_list.append(action) for action in filters['action'] if 'action' in filters]

        return list(set(actions_list))

    def extract_hw_sw_features(self):
        return list(set(self.apk.get_features()))

    def extract_api_calls(self):
        # _, _, dx = AnalyzeAPK(self.app_path)
        # Detailed way of completing the task on above line
        # dx = Analysis()
        # for dex_bytes in self.apk.get_all_dex():
        #     df = DalvikVMFormat(dex_bytes, using_api=self.apk.get_target_sdk_version())
        #     dx.add(df)
        #
        # dx.create_xref()

        api_calls = set()

        for cl in self.dx.get_external_classes():
            for meth in cl.get_methods():
                if meth.is_android_api():
                    tmp_list = str(meth.get_method()).split("(")
                    api_calls.add(tmp_list[0])

        return list(api_calls)

    def extract_metrics(self):
        # We are getting the first dex file out of the list of dexFiles to get results that are similar to the
        # results from the original Research Article.
        dex_file = self.dex_files[0]

        count_classes = 0
        count_methods = 0
        count_instructions = 0
        count_if_instructions = 0

        # Metrics to calculate
        methods_per_class = 0
        instructions_per_method = 0
        cyclomatic_complexity = 0
        cyclomatic_complexity_v2 = 0
        weighted_methods_per_class = 0

        total_fields = len(list(dex_file.get_fields()))

        # This for loop executes very fast, so no time complications here
        for dex_class in dex_file.get_classes():
            count_classes += 1
            for method in dex_class.get_methods():
                count_methods += 1
                for instruction in method.get_instructions():
                    count_instructions += 1
                    if instruction.get_name().startswith("if-"):
                        count_if_instructions += 1

        total_classes = count_classes
        total_methods = count_methods
        total_instructions = count_instructions
        total_if_instructions = count_if_instructions

        # Calculate metrics
        try:
            methods_per_class = total_methods / total_classes
            instructions_per_method = total_instructions / total_methods
            cyclomatic_complexity = (total_if_instructions + 1) / total_classes
            cyclomatic_complexity_v2 = (total_if_instructions + 1)
            weighted_methods_per_class = methods_per_class * total_if_instructions
        except Exception as e:
            print(f"Error calculating metrics: {str(e)}")

        metrics_list = ["Total Classes: " + str(total_classes),
                        "Total Methods: " + str(total_methods),
                        "Total Fields: " + str(total_fields),
                        "Total Instructions: " + str(total_instructions),
                        "Instructions Per Method: " + str(instructions_per_method),
                        "Methods Per Class: " + str(methods_per_class),
                        "Cyclomatic Complexity v1: " + str(cyclomatic_complexity),
                        "Cyclomatic Complexity v2: " + str(cyclomatic_complexity_v2),
                        "WMC: " + str(weighted_methods_per_class)]
        return metrics_list

    def get_queries(self):
        """
        Return the android:name attribute of all queries
        :rtype: a list of str
        """
        return list(self.queries)

    def get_intents_from_queries(self, itemtype='queries'):

        attributes = {"action": ["name"], "category": ["name"],
                      "data": ['scheme', 'host', 'port', 'path', 'pathPattern', 'pathPrefix', 'mimeType']}

        d = {}
        for element in attributes.keys():
            d[element] = []

        for i in self.apk.xml:
            # TODO: this can probably be solved using a single xpath
            for item in self.apk.xml[i].findall(".//" + itemtype):

                for sitem in item.findall(".//intent"):
                    # print(sitem)
                    for element in d.keys():
                        for ssitem in sitem.findall(element):
                            if element == 'action':

                                for attribute in attributes[element]:

                                    value = ssitem.get(self.apk._ns(attribute))
                                    if value.startswith('@'):
                                        value = self.get_res_value(value)

                                    if value not in d[element]:
                                        d[element].append(value)

        for element in list(d.keys()):
            if not d[element]:
                del d[element]

        return d['action']


def list_files(path):
    files_list = []
    for apk_file in os.listdir(path):
        file_path = os.path.join(path, apk_file)
        if os.path.isfile(file_path):
            temp_path = pathlib.Path(file_path)
            if temp_path.suffix == '.apk':
                files_list.append(file_path)
    return files_list


def create_features_file(feature_path, feature_name, a_name, feature_data):
    try:

        new_path = os.path.join(feature_path, a_name + feature_name + ".txt")

        with open(new_path, 'w') as file_obj:
            for data in feature_data:
                file_obj.write(data + '\n')

    except Exception as e:
        print(f"{e.__class__} occurred!\n {str(e)}")


def main():
    apk_files_list = []
    current_dir = os.path.dirname(__file__)
    dir_path = os.path.join(current_dir, "apks")
    apk_files_list = list_files(dir_path)

    for apk_path in apk_files_list:
        chosen_app = App(apk_path)
        apk_name = os.path.basename(apk_path)
        print(
            "--------------------------------------------------------------------------------------------------------------")
        print(f"Android app to be analyzed is {apk_name}")
        print(
            "--------------------------------------------------------------------------------------------------------------")

        app_name = apk_name.split(".")[0]

        try:
            features_path = os.path.join(current_dir, "ExtractedFeatures", app_name)
            if not os.path.exists(features_path):
                os.makedirs(features_path)  # Create parent directories if necessary
        except OSError as e:
            print(f"Error creating directory: {str(e)}")

        print("\nExtracting permissions...")
        perm_list = chosen_app.extract_permissions()
        create_features_file(features_path, "-permissions", app_name, perm_list)

        print("\nExtracting hardware and software features...")
        hw_sw_list = chosen_app.extract_hw_sw_features()
        create_features_file(features_path, "-hw-sw", app_name, hw_sw_list)

        # we get intent actions from queries as well but androguard and andropy do not include those
        print("\nExtracting all intent actions ...:")
        all_actions_list = list(set(chosen_app.extract_intent_actions() + chosen_app.get_intents_from_queries()))
        create_features_file(features_path, "-intent-actions", app_name, all_actions_list)

        print("\nExtracting API calls ...")
        all_api_list = chosen_app.extract_api_calls()
        create_features_file(features_path, "-api-calls", app_name, all_api_list)

        print("\nExtracting Metrics ...")
        all_metrics_list = chosen_app.extract_metrics()
        create_features_file(features_path, "-metrics", app_name, all_metrics_list)

        print(
            "--------------------------------------------------------------------------------------------------------------")
        print(f"End of analyzing {apk_name}")
        print(
            "--------------------------------------------------------------------------------------------------------------")


if __name__ == "__main__":
    t1 = time.time()
    main()
    t2 = time.time()
    print("Total time taken: ", t2 - t1, " seconds")
