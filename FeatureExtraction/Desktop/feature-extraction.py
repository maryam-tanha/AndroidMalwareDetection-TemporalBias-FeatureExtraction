import logging
import os
import pathlib
import time

from androguard.core.bytecodes.apk import APK
from androguard.misc import AnalyzeAPK
import asyncio
import csv

class App(object):
    """
    this class describes an app
    """

    def __init__(self, app_path):
        """
        create a App instance
        :param app_path: local file path of app
        :return:
        """
        assert app_path is not None
        self.logger = logging.getLogger(self.__class__.__name__)
        self.app_path = app_path
        self.apk, self.dex_files, self.dx = AnalyzeAPK(self.app_path)
        self.permissions = self.apk.get_permissions()
        self.package_name = self.apk.get_package()

    def extract_permissions(self):
        return set(list(self.permissions))

    def extract_metadata(self):
        package_name = self.apk.get_package()
        version_code = self.apk.get_androidversion_code()
        version_name = self.apk.get_androidversion_name()
        app_name = self.apk.get_app_name()
        sdk_version = self.apk.get_effective_target_sdk_version()
        valid_apk = self.apk.is_valid_APK()

        metadata_set = {
            f"package_name: {package_name}",
            f"version_code: {version_code}",
            f"version_name: {version_name}",
            f"app_name: {app_name}",
            f"sdk_version: {sdk_version}",
            f"valid_apk: {valid_apk}"
        }
        return metadata_set

    def extract_intent_actions(self):
        try:
            # Intent filter are attached to activities, services or receivers.
            activities = self.apk.get_activities()
            receivers = self.apk.get_receivers()
            services = self.apk.get_services()
            actions_list = []

            for i in activities:
                filters = self.apk.get_intent_filters("activity", i)
                if filters is not None and len(filters) > 0 and 'action' in filters:
                    actions_list.extend(filters['action'])

            for i in receivers:
                filters = self.apk.get_intent_filters("receiver", i)
                if filters is not None and len(filters) > 0 and 'action' in filters:
                    actions_list.extend(filters['action'])

            for i in services:
                filters = self.apk.get_intent_filters("service", i)
                if filters is not None and len(filters) > 0 and 'action' in filters:
                    actions_list.extend(filters['action'])

            if actions_list:
                return list(set(actions_list))
        except Exception as e:
            print(f"An error occurred over here: {e}")
            return None

    def extract_hw_sw_features(self):
        return list(set(self.apk.get_features()))

    def extract_api_calls(self):
        # _, _, dx = AnalyzeAPK(self.app_path)
        # Detailed way of completing the task on above line
        # dx = Analysis()
        # for dex_bytes in self.apk.get_all_dex():
        #     df = DalvikVMFormat(dex_bytes, using_api=self.apk.get_target_sdk_version())
        #     dx.add(df)
        #
        # dx.create_xref()

        api_calls = set()

        for cl in self.dx.get_external_classes():
            for meth in cl.get_methods():
                if meth.is_android_api():
                    tmp_list = str(meth.get_method()).split("(")
                    api_calls.add(tmp_list[0])

        return list(api_calls)

    def extract_metrics(self):
        # We are getting the first dex file out of the list of dexFiles to get results that are similar to the
        # results from the original Research Article.
        dex_files = self.dex_files

        count_classes = 0
        count_methods = 0
        count_fields = 0
        count_instructions = 0
        count_if_instructions = 0

        # Metrics to calculate
        methods_per_class = 0
        instructions_per_method = 0
        cyclomatic_complexity = 0
        cyclomatic_complexity_v2 = 0
        weighted_methods_per_class = 0

        all_classes = set()
        all_fields = set()
        all_methods = set()
        all_instructions = set()
        all_if_instructions = set()

        for dex_file in dex_files:
            # count_fields += len(list(dex_file.get_fields()))
            all_fields.update(list(dex_file.get_fields()))
            # This for loop executes very fast, so no time complications here
            for dex_class in dex_file.get_classes():
                # count_classes += 1
                all_classes.add(dex_class.get_name())
                for method in dex_class.get_methods():
                    # count_methods += 1
                    all_methods.add(method.get_name())
                    for instruction in method.get_instructions():
                        # count_instructions += 1
                        all_instructions.add(instruction.get_name())
                        if instruction.get_name().startswith("if-"):
                            # count_if_instructions += 1
                            all_if_instructions.add(instruction.get_name())

        # total_classes = count_classes
        # total_fields = count_fields
        # total_methods = count_methods
        # total_instructions = count_instructions
        # total_if_instructions = count_if_instructions

        my_list = list(all_instructions)
        file_path = "output.txt"
        with open(file_path, "w") as file:
            for item in my_list:
                file.write(str(item) + "\n")

        total_classes = len(all_classes)
        total_fields = len(all_fields)
        total_methods = len(all_methods)
        total_instructions = len(all_instructions)
        total_if_instructions = len(all_if_instructions)

        # Calculate metrics
        try:
            methods_per_class = total_methods / total_classes
            instructions_per_method = total_instructions / total_methods
            cyclomatic_complexity = (total_if_instructions + 1) / total_classes
            cyclomatic_complexity_v2 = (total_if_instructions + 1)
            weighted_methods_per_class = methods_per_class * total_if_instructions
        except Exception as e:
            print(f"Error calculating metrics: {str(e)}")

        metrics_list = ["Total Classes: " + str(total_classes),
                        "Total Methods: " + str(total_methods),
                        "Total Fields: " + str(total_fields),
                        "Total Instructions: " + str(total_instructions),
                        "Instructions Per Method: " + str(instructions_per_method),
                        "Methods Per Class: " + str(methods_per_class),
                        "Cyclomatic Complexity v1: " + str(cyclomatic_complexity),
                        "Cyclomatic Complexity v2: " + str(cyclomatic_complexity_v2),
                        "WMC: " + str(weighted_methods_per_class)]
        return metrics_list

    def get_queries(self):
        """
        Return the android:name attribute of all queries
        :rtype: a list of str
        """
        return list(self.queries)

    def get_intents_from_queries(self, itemtype='queries'):
        try:
            attributes = {"action": ["name"], "category": ["name"],
                          "data": ['scheme', 'host', 'port', 'path', 'pathPattern', 'pathPrefix', 'mimeType']}

            d = {element: [] for element in attributes.keys()}

            for i in self.apk.xml:
                # TODO: this can probably be solved using a single xpath
                for item in self.apk.xml[i].findall(".//" + itemtype):
                    for sitem in item.findall(".//intent"):
                        # print(sitem)
                        for element in d.keys():
                            for ssitem in sitem.findall(element):
                                if element == 'action':
                                    for attribute in attributes[element]:
                                        value = ssitem.get(self.apk._ns(attribute))
                                        if value and value.startswith('@'):
                                            value = self.get_res_value(value)
                                        if value and value not in d[element]:
                                            d[element].append(value)

            # Filter out empty lists and non-action elements
            d = {key: value for key, value in d.items() if value and key == 'action'}
            return d.get('action', [])
        except Exception as e:
            print(f"An error occurred: {e}")
            return None


def list_files(path):
    files_list = []
    for apk_file in os.listdir(path):
        file_path = os.path.join(path, apk_file)
        if os.path.isfile(file_path):
            temp_path = pathlib.Path(file_path)
            if temp_path.suffix == '.apk':
                files_list.append(file_path)
    return files_list


def create_features_file(feature_path, feature_name, a_name, feature_data):
    try:
        new_path = os.path.join(feature_path, a_name + feature_name + ".txt")
        with open(new_path, 'w', encoding='utf-8') as file_obj:
            for data in feature_data:
                file_obj.write(data + '\n')

    except Exception as e:
        print(f"{e.__class__} occurred!\n {str(e)}")


async def process_apk(apk_path, error_apks):
    global features_path
    try:
        chosen_app = App(apk_path)
        apk_name = os.path.basename(apk_path)
        print(
            "--------------------------------------------------------------------------------------------------------------")
        print(f"Android app to be analyzed is {apk_name}")
        print(
            "--------------------------------------------------------------------------------------------------------------")

        app_name = apk_name.split(".")[0]

        try:
            features_path = os.path.join("E:\\AZ500-features", app_name)
            if not os.path.exists(features_path):
                os.makedirs(features_path)  # Create parent directories if necessary
        except OSError as e:
            print(f"Error creating directory: {str(e)}")

        print("\nExtracting Metadata ...")
        metadata_list = chosen_app.extract_metadata()
        create_features_file(features_path, "-metadata", app_name, metadata_list)

        print("\nExtracting permissions...")
        perm_list = chosen_app.extract_permissions()
        create_features_file(features_path, "-permissions", app_name, perm_list)

        print("\nExtracting hardware and software features...")
        hw_sw_list = chosen_app.extract_hw_sw_features()
        create_features_file(features_path, "-hw-sw", app_name, hw_sw_list)

        print("\nExtracting API calls ...")
        all_api_list = chosen_app.extract_api_calls()
        create_features_file(features_path, "-api-calls", app_name, all_api_list)

        print("\nExtracting all intent actions ...:")
        intent_actions = chosen_app.extract_intent_actions()
        intent_from_queries = chosen_app.get_intents_from_queries()

        if intent_actions is None and intent_from_queries is None:
            raise ValueError("There was an error while getting the intents from queries and actions.")
        elif intent_actions is None:
            all_actions_list = list(set(intent_from_queries))
        elif intent_from_queries is None:
            all_actions_list = list(set(intent_actions))
        else:
            all_actions_list = list(set(intent_actions + intent_from_queries))
        create_features_file(features_path, "-intent-actions", app_name, all_actions_list)

        print(
            "--------------------------------------------------------------------------------------------------------------")
        print(f"End of analyzing {apk_name}")
    except Exception as e:
        print(f"Error Occurred: {e}")
        error_apks.append(apk_path)


async def main():
    error_apks = []
    apk_files_list = []
    paths = ["E:\\AZ500"]
    for path in paths:
        apk_files_list.extend(list_files(path))

    print(f"Total apks to process: {len(apk_files_list)}")
    tasks = [process_apk(apk_path, error_apks) for apk_path in apk_files_list]

    # Run the tasks concurrently using asyncio
    await asyncio.gather(*tasks)

    with open("errorAPKSV2.txt", mode="w", newline="") as error_output:
        writer = csv.writer(error_output)
        for error in error_apks:
            writer.writerow([error])


if __name__ == "__main__":
    asyncio.run(main())
